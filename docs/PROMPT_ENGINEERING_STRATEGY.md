# プロンプトエンジニアリング戦略ガイド

## 🎯 目的
AI開発ワークフローにおいて、各フェーズで最適なプロンプトを体系的に管理・活用し、AIの出力品質を最大化する。

## 📚 プロンプトライブラリの階層構造

### 1. 基本プロンプト（Base Prompts）
全フェーズ共通で使用する基礎的なプロンプト

### 2. フェーズ特化プロンプト（Phase-Specific Prompts）
各開発フェーズに最適化されたプロンプト

### 3. タスク特化プロンプト（Task-Specific Prompts）
具体的なタスク（コードレビュー、テスト生成等）向けプロンプト

### 4. プロジェクト特化プロンプト（Project-Specific Prompts）
プロジェクトの技術スタック・業界に特化したプロンプト

## 🏗️ プロンプト構造標準

### 基本構造
```text
# [プロンプト名]

## ロール設定
あなたは[具体的な役割・専門性]です。

## コンテキスト
[プロジェクト文脈・制約条件・前提知識]

## タスク
[具体的にやってほしいこと]

## 出力形式
[期待する出力の形式・構造]

## 品質基準
[出力の品質要件・チェックポイント]

## 例外処理
[不明確な場合の対応方法]
```

## 📋 フェーズ別プロンプト戦略

### Phase 1: 要件定義
**目標**: ビジネス価値と技術実現性のバランス取れた要件抽出

#### 要件洗い出しプロンプト
```text
# 包括的要件洗い出し

## ロール設定
あなたは10年以上の経験を持つプロダクトマネージャー兼システムアーキテクトです。

## コンテキスト
プロジェクト: [PROJECT_CONTEXT.mdの内容]
業界: [業界固有の制約・規制]
チーム: [チーム構成・スキルレベル]

## タスク
以下の観点から、体系的に要件を洗い出してください：
1. 機能要件（Must/Should/Could/Won't分類）
2. 非機能要件（性能・セキュリティ・運用性等）
3. ビジネス制約（予算・期間・リソース）
4. 技術制約（既存システム・インフラ・スキル）

## 出力形式
- 要件一覧（優先度付き）
- リスク分析
- 実現性評価（1-5段階）
- 依存関係マップ

## 品質基準
- 測定可能な要件定義
- ステークホルダー観点の網羅
- 技術的実現性の現実的評価

## 例外処理
不明確な要件は仮定を明記し、確認事項として列挙してください。
```

#### 技術選定支援プロンプト
```text
# 技術スタック選定支援

## ロール設定
あなたは様々な技術スタックに精通したシステムアーキテクトです。

## コンテキスト
要件: [Phase1で確定した要件]
制約: [技術的・ビジネス的制約]
チーム: [技術スキル・経験]

## タスク
以下の基準で技術選定を支援してください：
1. 要件適合度（機能・非機能）
2. チーム適合度（学習コスト・経験）
3. エコシステム（コミュニティ・将来性）
4. 運用性（監視・デバッグ・メンテナンス）

## 出力形式
- 推奨技術スタック（第1-3候補）
- 比較表（pros/cons）
- 移行パス（段階的採用戦略）
- リスク評価

## 品質基準
- 複数選択肢の客観的比較
- 短期・長期両方の観点
- 具体的な根拠・事例の提示
```

### Phase 2: PoC開発
**目標**: 最小限の実装で最大限の学習・リスク検証

#### PoC設計プロンプト
```text
# PoC設計戦略

## ロール設定
あなたは技術的リスクの早期発見に長けたシニアエンジニアです。

## コンテキスト
確定要件: [Phase1の成果物]
選定技術: [選定された技術スタック]
検証期間: [PoC期間制約]

## タスク
以下を考慮してPoC設計を行ってください：
1. 最重要リスクの特定（技術・性能・統合性）
2. 最小検証スコープの設定
3. 成功・失敗基準の明確化
4. 本実装への移行判断基準

## 出力形式
- PoC設計書
- 検証項目チェックリスト
- 技術スパイク計画
- 移行判断マトリクス

## 品質基準
- リスクベース優先順位付け
- 測定可能な成功基準
- 実装工数の現実的見積もり
```

### Phase 3-4: 実装・レビュー
**目標**: 保守性・拡張性・品質を担保した実装

#### コード生成プロンプト
```text
# 高品質コード生成

## ロール設定
あなたは[技術スタック]のエキスパートで、保守性の高いコードを書くことで有名です。

## コンテキスト
アーキテクチャ: [PoC結果のアーキテクチャ]
コーディング規約: [CODING_STANDARDS.mdの内容]
既存コード: [関連する既存実装]

## タスク
以下の仕様に基づいてコードを実装してください：
[具体的な機能仕様]

## 出力形式
- メイン実装コード
- 単体テストコード
- 統合テストシナリオ
- ドキュメント（API仕様等）

## 品質基準
- コーディング規約準拠
- テストカバレッジ80%以上
- エラーハンドリング完備
- パフォーマンス考慮

## 例外処理
実装困難な仕様は代替案を提示してください。
```

#### コードレビュープロンプト
```text
# 包括的コードレビュー

## ロール設定
あなたは厳格で建設的なシニアエンジニアです。

## コンテキスト
PR概要: [Pull Requestの説明]
関連Issue: [実装対象のIssue]
アーキテクチャ: [システム全体設計]

## タスク
以下の観点でコードレビューを実施してください：
1. 機能的正確性
2. セキュリティ（脆弱性・認証認可）
3. パフォーマンス（ボトルネック・最適化）
4. 保守性（可読性・拡張性）
5. テスト品質

## 出力形式
- 重要度別フィードバック（Critical/Major/Minor）
- 具体的修正提案
- 優れている点の言及
- 学習・参考資料の提示

## 品質基準
- 建設的で具体的なフィードバック
- セキュリティリスクの徹底チェック
- ベストプラクティスの共有
```

### Phase 5: テスト・デプロイ
**目標**: 自動化されたテスト戦略と安全なデプロイ

#### テスト戦略プロンプト
```text
# 包括的テスト戦略設計

## ロール設定
あなたはテスト自動化とQAのエキスパートです。

## コンテキスト
実装内容: [Phase3-4の成果物]
品質要件: [非機能要件・SLA]
リリース戦略: [デプロイ・ロールバック方針]

## タスク
以下のテスト戦略を設計してください：
1. テストピラミッド（Unit/Integration/E2E比率）
2. テストデータ戦略（生成・管理・マスキング）
3. パフォーマンステスト（負荷・ストレス・耐久性）
4. セキュリティテスト（脆弱性・侵入・認証）
5. 運用テスト（監視・ログ・アラート）

## 出力形式
- テスト計画書
- 自動化テストコード
- テストデータセット
- CI/CDパイプライン設定

## 品質基準
- 実行時間効率性
- メンテナンス容易性
- カバレッジ網羅性
```

## 🔧 プロンプト管理ツール

### 1. プロンプトバージョニング
```bash
prompts/
├── v1.0/
│   ├── base/
│   ├── requirements/
│   ├── poc/
│   ├── implementation/
│   └── testing/
└── v1.1/
    └── ...
```

### 2. プロンプト効果測定
```yaml
# prompt-metrics.yml
prompt_id: "requirements-extraction-v1.2"
usage_count: 45
success_rate: 0.89
avg_response_quality: 4.2
feedback_summary: "要件の網羅性が向上、ただし技術的実現性評価に課題"
improvements: "技術制約をより詳細に含める"
next_version: "v1.3"
```

### 3. プロンプト最適化サイクル
1. **計測**: プロンプト使用結果の品質測定
2. **分析**: 失敗パターン・改善点の特定
3. **改善**: プロンプト構造・文言の最適化
4. **検証**: A/Bテストによる効果確認

## 📊 成功指標

### 定量指標
- プロンプト再利用率
- AI出力の受入率
- レビュー指摘事項の削減率
- 開発速度の向上率

### 定性指標
- AI出力の一貫性
- チーム満足度
- 学習効果の継続性

---

この戦略により、プロジェクト全体を通じてAIとの協働効果を最大化し、継続的に改善される高品質な開発プロセスを実現します。
